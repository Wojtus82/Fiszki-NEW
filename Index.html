<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fiszki WOJTUKIEWICZ - No "Kropka" Fix</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

    <style>
        .perspective-1000 { perspective: 1000px; }
        .transform-style-3d { transform-style: preserve-3d; }
        .backface-hidden { backface-visibility: hidden; -webkit-backface-visibility: hidden; }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fadeIn { animation: fadeIn 0.3s ease-in-out; }
        
        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .animate-popIn { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

        .animate-slideIn { animation: fadeIn 0.3s ease-out; }

        @keyframes spinThreeTimes { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(1080deg); } 
        }
        .animate-spin-three { animation: spinThreeTimes 3s ease-in-out; }

        @keyframes startUpShake {
            0% { transform: scale(1) rotate(0deg); }
            15% { transform: scale(1.6) rotate(-25deg); }
            30% { transform: scale(2.2) rotate(25deg); }
            45% { transform: scale(1.6) rotate(-25deg); }
            60% { transform: scale(1.2) rotate(25deg); }
            75% { transform: scale(1.1) rotate(-10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .startup-anim {
            display: inline-block;
            transform-origin: center center;
            animation: startUpShake 1.5s ease-in-out 2;
        }

        .transition-colors-all { 
            transition-property: background-color, border-color, color, fill, stroke, background-image, box-shadow; 
            transition-duration: 500ms; 
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); 
        }

        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        
        #error-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.98); z-index: 9999; flex-direction: column; align-items: center; justify-content: center; color: #991b1b; padding: 20px; text-align: center; }
        .no-tap-highlight { -webkit-tap-highlight-color: transparent; }
        
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .item-multi-selected {
            background-color: #ecfdf5 !important;
            border-color: #10b981 !important;
            color: #065f46 !important;
        }
        .dark .item-multi-selected {
            background-color: #064e3b !important;
            border-color: #10b981 !important;
            color: #d1fae5 !important;
        }
    </style>
</head>
<body class="m-0 transition-colors-all no-tap-highlight overflow-hidden">

    <div id="error-overlay">
        <h2 class="text-2xl font-bold mb-2">Wystąpił błąd</h2>
        <p class="mb-4 text-gray-600">Nie udało się załadować bazy danych Excel.</p>
        <div id="local-file-warning" class="hidden mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg text-yellow-800 text-sm max-w-md text-left">
            <strong>⚠️ Wykryto uruchomienie lokalne (file://)</strong><br/><br/>
            Przeglądarki mogą blokować wczytywanie pliku <code>bazaA1.xlsx</code> z dysku ze względów bezpieczeństwa (CORS).<br/>
            Aby to działało lokalnie, najlepiej uruchomić prosty serwer (np. Live Server w VS Code).
        </div>
        <pre id="error-message" class="bg-red-100 p-4 rounded text-sm text-left overflow-auto max-w-full max-h-64 select-text"></pre>
        <button onclick="location.reload()" class="bg-red-600 text-white px-6 py-3 rounded-xl font-bold shadow-lg hover:bg-red-700 transition mt-4">Spróbuj ponownie</button>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line, col, error) {
            document.getElementById('error-overlay').style.display = 'flex';
            document.getElementById('error-message').textContent = `JS Error: ${msg}\nLine: ${line}`;
            if (window.location.protocol === 'file:') {
                document.getElementById('local-file-warning').style.display = 'block';
            }
            return false;
        };
    </script>

    <script type="text/babel">
        try {
            const { useState, useEffect, useMemo, useRef } = React;

            const Icon = ({ path, size = 24, className="" }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
            );

            const iconPaths = {
                layers: <><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></>,
                book: <><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></>,
                rotate: <><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></>,
                left: <><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></>,
                right: <><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></>,
                vol: <><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></>,
                volX: <><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></>,
                tag: <><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></>,
                clock: <><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></>,
                moon: <><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></>,
                sun: <><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></>,
                close: <><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>,
                trophy: <><path d="M8 21h8"/><path d="M12 17v4"/><path d="M7 4h10"/><path d="M17 4v8a5 5 0 0 1-10 0V4"/><path d="M5 9v1a2 2 0 0 0 2 2"/><path d="M19 9v1a2 2 0 0 1-2 2"/></>,
                reloadCustom: <><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></>,
                play: <polygon points="5 3 19 12 5 21 5 3" fill="currentColor"/>,
                pause: <><rect x="6" y="4" width="4" height="16" fill="currentColor" /><rect x="14" y="4" width="4" height="16" fill="currentColor" /></>,
                swap: <><path d="M7 16V4M7 4L3 8M7 4L11 8"/><path d="M17 8v12M17 20l4-4M17 20l-4-4"/></>,
                check: <polyline points="20 6 9 17 4 12"></polyline>,
                filter: <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>,
                square: <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>,
                checkSquare: <><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><polyline points="9 11 12 14 22 4"></polyline></>,
                barChart: <><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></>
            };

            const parseSentenceRow = (text) => {
                if (!text) return null;
                const str = String(text); 
                const lastParenIndex = str.lastIndexOf('(');
                if (lastParenIndex === -1) return { en: str.trim(), pl: '' };
                const en = str.substring(0, lastParenIndex).trim();
                const pl = str.substring(lastParenIndex + 1, str.length - 1).trim(); 
                return { en, pl };
            };

            const extractSentencesFromCell = (cellContent, isBeginner = false) => {
                if (!cellContent) return [];
                let strContent = String(cellContent);

                if (isBeginner) {
                    strContent = strContent.replace(/(\r\n|\n|\r)/gm, " ");
                    strContent = strContent.replace(/([0-9]+\.)/g, "\n$1");
                    const lines = strContent.split('\n');
                    return lines
                        .map(line => line.trim())
                        .filter(line => line.length > 0)
                        .map(line => ({ en: line, pl: '' })); 
                } else {
                    strContent = strContent.trim();
                    strContent = strContent.replace(/(?:^|\s+)([1-5]\.)\s*/g, '\n$1 ');
                    strContent = strContent.replace(/\)/g, ')\n');
                    
                    const lines = strContent.split(/\r?\n/).filter(line => line.trim() !== "");
                    return lines.map(line => parseSentenceRow(line)).filter(s => s && s.en);
                }
            };

            const getWordSizeClass = (text) => {
                if (!text) return "text-5xl sm:text-7xl";
                const len = text.length;
                if (len < 12) return "text-5xl sm:text-7xl"; 
                if (len < 20) return "text-4xl sm:text-6xl"; 
                if (len < 30) return "text-3xl sm:text-5xl"; 
                return "text-xl sm:text-3xl"; 
            };

            const getTranslationSizeClass = (text) => {
                if (!text) return "text-5xl sm:text-6xl";
                const len = text.length;
                if (len < 15) return "text-5xl sm:text-6xl"; 
                if (len < 30) return "text-3xl sm:text-5xl"; 
                if (len < 50) return "text-2xl sm:text-3xl"; 
                return "text-lg sm:text-xl"; 
            };
            
            const getPhoneticSizeClass = (text) => {
                if (!text) return "text-3xl sm:text-4xl";
                const len = text.length;
                if (len < 20) return "text-3xl sm:text-4xl";
                return "text-xl sm:text-2xl";
            };

            function FlashcardsApp() {
                const [fullDatabase, setFullDatabase] = useState([]);
                const [loading, setLoading] = useState(true);
                const [fileError, setFileError] = useState(null);

                // --- STATES FOR LEVEL SELECTION ---
                const [selectedLevels, setSelectedLevels] = useState(['A1']); 
                const [isLevelModalOpen, setIsLevelModalOpen] = useState(false);
                const [tempSelectedLevels, setTempSelectedLevels] = useState([]);
                const availableLevels = ['A1', 'A2', 'B1', 'B2'];

                // --- STATES FOR CATEGORY SELECTION ---
                const [selectedCategories, setSelectedCategories] = useState([]); 
                const [isCategoryModalOpen, setIsCategoryModalOpen] = useState(false);
                const [tempSelectedCategories, setTempSelectedCategories] = useState([]); 
                
                const [tense, setTense] = useState('Base');
                
                const [availableCategories, setAvailableCategories] = useState([]);
                const [currentWordIds, setCurrentWordIds] = useState([]);
                const [currentIndex, setCurrentIndex] = useState(0);
                const [isFinished, setIsFinished] = useState(false);
                
                const [cardSide, setCardSide] = useState(1);
                const [rotation, setRotation] = useState(0);
                const [noTransition, setNoTransition] = useState(false);
                
                const [isSpeaking, setIsSpeaking] = useState(false);
                const [isPaused, setIsPaused] = useState(false);

                const [isPlToEn, setIsPlToEn] = useState(false);

                const [isDarkMode, setIsDarkMode] = useState(() => {
                    const savedTheme = localStorage.getItem('flashcards-theme');
                    return savedTheme === 'dark';
                });
                
                const [isStartAnimating, setIsStartAnimating] = useState(false);
                const [oledMode, setOledMode] = useState(false);

                const [viewAllSentences, setViewAllSentences] = useState(false);
                const [activeSentenceIndex, setActiveSentenceIndex] = useState(null);
                
                const [speakingSentenceIndex, setSpeakingSentenceIndex] = useState(0);
                
                const [voices, setVoices] = useState([]);
                const [selectedVoice, setSelectedVoice] = useState(null);
                const [selectedPlVoice, setSelectedPlVoice] = useState(null);

                const [touchStart, setTouchStart] = useState(null);
                const [touchEnd, setTouchEnd] = useState(null);
                const minSwipeDistance = 50;

                const wakeLockRef = useRef(null);
                const itemRefs = useRef([]); 
                
                const queueRef = useRef([]);
                const queueIndexRef = useRef(0);
                const pausedIntentionally = useRef(false);
                const isPausedRef = useRef(false);
                
                const lastTapRef = useRef(0);
                const tapCountRef = useRef(0);

                useEffect(() => {
                    localStorage.setItem('flashcards-theme', isDarkMode ? 'dark' : 'light');
                }, [isDarkMode]);

                useEffect(() => {
                    const startTimer = setTimeout(() => {
                        setIsStartAnimating(true);
                        const endTimer = setTimeout(() => {
                            setIsStartAnimating(false);
                        }, 3000); 
                        return () => clearTimeout(endTimer);
                    }, 3000);
                    return () => clearTimeout(startTimer);
                }, []);

                useEffect(() => {
                    const loadVoices = () => {
                        const availableVoices = window.speechSynthesis.getVoices();
                        setVoices(availableVoices);
                    };
                    loadVoices();
                    if (window.speechSynthesis.onvoiceschanged !== undefined) {
                        window.speechSynthesis.onvoiceschanged = loadVoices;
                    }
                }, []);

                useEffect(() => {
                    if (voices.length > 0) {
                        const bestVoice = 
                            voices.find(v => v.name.includes("Google US English")) ||
                            voices.find(v => v.name.includes("Google UK English Female")) ||
                            voices.find(v => v.name.includes("Samantha")) || 
                            voices.find(v => v.name.includes("Zira")) ||
                            voices.find(v => v.lang === 'en-US' && v.name.includes("Natural")) ||
                            voices.find(v => v.lang === 'en-US') ||
                            voices.find(v => v.lang.startsWith('en'));
                        if (bestVoice) setSelectedVoice(bestVoice);
                        
                        const bestPl = 
                                voices.find(v => v.name.includes("Google Polski")) ||
                                voices.find(v => v.lang === 'pl-PL' && v.name.includes("Paulina")) ||
                                voices.find(v => v.lang === 'pl-PL');
                        if (bestPl) setSelectedPlVoice(bestPl);
                    }
                }, [voices]);

                const getColumnValue = (row, colName) => {
                    const keys = Object.keys(row);
                    const matchingKey = keys.find(k => k.trim().toLowerCase() === colName.toLowerCase());
                    return matchingKey ? row[matchingKey] : undefined;
                };

                useEffect(() => {
                    setLoading(true);
                    const excelUrl = `bazaA1.xlsx?t=${new Date().getTime()}`;
                    
                    fetch(excelUrl)
                        .then(res => {
                            if (!res.ok) throw new Error(`Błąd sieci: ${res.status} ${res.statusText}`);
                            return res.arrayBuffer();
                        })
                        .then(ab => {
                            const workbook = XLSX.read(ab, { type: 'array' });
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);

                            if (jsonData && jsonData.length > 0) {
                                const tenseColumns = [
                                    "Present Simple", "Present continuous", "Past Simple", 
                                    "Future Simple", "Present Perfect", "Past Continuous", "Going To",
                                    "Questions", "Początkujący", "Beginner"
                                ];
                                const processedData = [];
                                jsonData.forEach(row => {
                                    const id = row.id;
                                    const rawLevel = row.level ? String(row.level).trim() : "A1";
                                    const rawCat = row.category ? String(row.category).trim() : "Inne";
                                    const word = row.word ? String(row.word).trim() : "";
                                    const translation = row.translation ? String(row.translation).trim() : "";
                                    const phonetic = row.phonetic ? String(row.phonetic).trim() : "";
                                    
                                    const baseSentences = extractSentencesFromCell(row.base);
                                    processedData.push({
                                        id: id, level: rawLevel, category: rawCat, word: word, translation: translation,
                                        phonetic: phonetic, tense: 'Base', sentencesList: baseSentences
                                    });

                                    tenseColumns.forEach(tenseName => {
                                        const cellVal = getColumnValue(row, tenseName);
                                        if (cellVal) {
                                            const isBeginner = tenseName === "Beginner" || tenseName === "Początkujący";
                                            const tenseSentences = extractSentencesFromCell(cellVal, isBeginner);
                                            
                                            if (tenseSentences.length > 0) {
                                                processedData.push({
                                                    id: id, level: rawLevel, category: rawCat, word: word, translation: translation,
                                                    phonetic: phonetic, tense: tenseName, sentencesList: tenseSentences
                                                });
                                            }
                                        }
                                    });
                                });
                                setFullDatabase(processedData);
                                setLoading(false);
                            } else {
                                setFileError("Plik Excel wygląda na pusty.");
                                setLoading(false);
                            }
                        })
                        .catch(err => {
                            console.error(err);
                            setFileError(`Błąd wczytywania Excela: ${err.message}. Upewnij się, że plik 'bazaA1.xlsx' jest w tym samym folderze.`);
                            setLoading(false);
                        });
                }, []);

                useEffect(() => {
                    if (!fullDatabase.length) { setAvailableCategories([]); return; }
                    
                    const filteredRows = fullDatabase.filter(row => selectedLevels.includes(row.level));
                    
                    const cats = [...new Set(filteredRows.map(row => row.category))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' }));
                    setAvailableCategories(cats);
                    
                    setSelectedCategories([]);
                    setTempSelectedCategories([]);
                }, [selectedLevels, fullDatabase]);

                useEffect(() => {
                    if (!fullDatabase.length) return;
                    
                    const uniqueIds = [...new Set(fullDatabase.filter(row => {
                        const levelMatch = selectedLevels.includes(row.level);
                        const catMatch = selectedCategories.length === 0 ? true : selectedCategories.includes(row.category);
                        return levelMatch && catMatch;
                    }).map(row => row.id))];
                    
                    const shuffledIds = [...uniqueIds].sort(() => Math.random() - 0.5);
                    setCurrentWordIds(shuffledIds);
                    setCurrentIndex(0);
                    setIsFinished(false);
                    resetCard();
                }, [selectedCategories, selectedLevels, fullDatabase]);


                // --- LOGIKA MULTI SELECT ---

                const openCategoryModal = () => {
                    setTempSelectedCategories([...selectedCategories]);
                    setIsCategoryModalOpen(true);
                };
                const closeCategoryModal = () => setIsCategoryModalOpen(false);

                const handleSingleSelectCategory = (cat) => {
                    setSelectedCategories([cat]);
                    setTempSelectedCategories([cat]);
                    closeCategoryModal();
                };

                const handleMultiToggleCategory = (e, cat) => {
                    e.stopPropagation();
                    setTempSelectedCategories(prev => {
                        if (prev.includes(cat)) return prev.filter(c => c !== cat);
                        return [...prev, cat];
                    });
                };

                const confirmMultiCategorySelection = () => {
                    setSelectedCategories([...tempSelectedCategories]);
                    closeCategoryModal();
                };

                const getCategoryLabel = () => {
                    if (selectedCategories.length === 0) return "Wszystkie (Default)";
                    if (selectedCategories.length === 1) return selectedCategories[0];
                    return `Wybrano: ${selectedCategories.length}`;
                };

                const openLevelModal = () => {
                    setTempSelectedLevels([...selectedLevels]);
                    setIsLevelModalOpen(true);
                };
                const closeLevelModal = () => setIsLevelModalOpen(false);

                const handleSingleSelectLevel = (lvl) => {
                    setSelectedLevels([lvl]);
                    setTempSelectedLevels([lvl]);
                    closeLevelModal();
                };

                const handleMultiToggleLevel = (e, lvl) => {
                    e.stopPropagation();
                    setTempSelectedLevels(prev => {
                        if (prev.includes(lvl)) return prev.filter(l => l !== lvl);
                        return [...prev, lvl];
                    });
                };

                const confirmMultiLevelSelection = () => {
                    if (tempSelectedLevels.length === 0) {
                        alert("Musisz wybrać przynajmniej jeden poziom.");
                        return;
                    }
                    setSelectedLevels([...tempSelectedLevels]);
                    closeLevelModal();
                };

                const getLevelLabel = () => {
                    if (selectedLevels.length === 0) return "Brak";
                    if (selectedLevels.length === 1) return selectedLevels[0];
                    return `Wybrano: ${selectedLevels.length}`;
                };

                // --- END MULTI SELECT ---

                const availableTenses = useMemo(() => {
                        if (!currentWordIds.length || !fullDatabase.length) return [];
                        const currentId = currentWordIds[currentIndex];
                        
                        const rows = fullDatabase.filter(row => 
                            row.id === currentId && 
                            selectedLevels.includes(row.level) &&
                            (selectedCategories.length === 0 || selectedCategories.includes(row.category))
                        );

                        const tenses = rows.map(r => r.tense).filter(t => t && t !== 'Base');
                        return [...new Set(tenses)];
                }, [currentWordIds, currentIndex, fullDatabase, selectedLevels, selectedCategories]);

                const allCategorySentences = useMemo(() => {
                    if (!viewAllSentences) return [];
                    if (!fullDatabase.length) return [];
                    if (!currentWordIds.length) return [];
                    let sentences = [];
                    currentWordIds.forEach((id, idx) => {
                        const wordRows = fullDatabase.filter(row => 
                            row.id === id && 
                            selectedLevels.includes(row.level) &&
                            (selectedCategories.length === 0 || selectedCategories.includes(row.category))
                        );

                        let rowsToProcess = [];
                        if (tense === 'mixed') rowsToProcess = wordRows.filter(r => r.tense !== 'Base');
                        else rowsToProcess = wordRows.filter(r => r.tense === tense);

                        rowsToProcess.forEach(row => {
                            if (row.sentencesList && row.sentencesList.length > 0) {
                                row.sentencesList.forEach(s => {
                                    sentences.push({ ...s, word: row.word, wordIndex: idx, phonetic: row.phonetic }); 
                                });
                            }
                        });
                    });
                    return sentences;
                }, [viewAllSentences, currentWordIds, fullDatabase, tense, selectedLevels, selectedCategories]);

                useEffect(() => {
                    itemRefs.current = [];
                    setSpeakingSentenceIndex(0);
                }, [allCategorySentences, viewAllSentences]);

                const getDisplayData = () => {
                    if (!fullDatabase.length) return null;
                    if (!currentWordIds.length) return { isEmpty: true, word: "Brak słówek", translation: "Spróbuj zmienić kategorię lub poziom", phonetic: "---", sentences: [] };

                    const currentId = currentWordIds[currentIndex];

                    const validRows = fullDatabase.filter(row => 
                        row.id === currentId &&
                        selectedLevels.includes(row.level) &&
                        (selectedCategories.length === 0 || selectedCategories.includes(row.category))
                    );

                    const baseRow = validRows.find(row => row.tense === 'Base');
                    const fallbackRow = validRows[0]; 
                    const mainInfoRow = baseRow || fallbackRow;
                    
                    if (!mainInfoRow) return null;

                    let sentences = [];
                    if (tense === 'mixed') {
                        const allVariations = validRows.filter(row => row.tense !== 'Base');
                        allVariations.forEach(row => { if (row.sentencesList) sentences.push(...row.sentencesList); });
                        sentences = sentences.sort(() => Math.random() - 0.5).slice(0, 5);
                    } else if (tense === 'Base') {
                        if (baseRow && baseRow.sentencesList) sentences = baseRow.sentencesList;
                    } else {
                        const activeRow = validRows.find(row => row.tense === tense);
                        if (activeRow && activeRow.sentencesList) sentences = activeRow.sentencesList;
                    }
                    return { word: mainInfoRow.word, translation: mainInfoRow.translation, phonetic: mainInfoRow.phonetic, sentences: sentences };
                };

                const displayData = getDisplayData();
                const sentencesListToRender = viewAllSentences ? allCategorySentences : (displayData ? displayData.sentences : []);

                const currentPhoneticToDisplay = useMemo(() => {
                    if (viewAllSentences) {
                        if (activeSentenceIndex !== null && sentencesListToRender[activeSentenceIndex]) {
                            return sentencesListToRender[activeSentenceIndex].phonetic;
                        }
                        if (sentencesListToRender[speakingSentenceIndex]) {
                            return sentencesListToRender[speakingSentenceIndex].phonetic;
                        }
                    }
                    return displayData ? displayData.phonetic : "";
                }, [viewAllSentences, activeSentenceIndex, speakingSentenceIndex, sentencesListToRender, displayData]);

                const handleStart = (clientX) => { setTouchEnd(null); setTouchStart(clientX); };
                const handleMove = (clientX) => { setTouchEnd(clientX); };
                const handleEnd = () => {
                    if (!touchStart || !touchEnd) return;
                    const distance = touchStart - touchEnd;
                    if (distance > minSwipeDistance) handleNext();
                    else if (distance < -minSwipeDistance) handlePrev();
                    setTouchStart(null); setTouchEnd(null);
                };

                const onTouchStart = (e) => handleStart(e.targetTouches[0].clientX);
                const onTouchMove = (e) => handleMove(e.targetTouches[0].clientX);
                const onTouchEnd = () => handleEnd();
                const onMouseDown = (e) => handleStart(e.clientX);
                const onMouseMove = (e) => { if(touchStart) handleMove(e.clientX); };
                const onMouseUp = () => {
                    if (touchStart && touchEnd && Math.abs(touchStart - touchEnd) > minSwipeDistance) handleEnd();
                    setTouchStart(null); setTouchEnd(null);
                };
                const onMouseLeave = () => { setTouchStart(null); setTouchEnd(null); };

                const handleTripleTap = (callback) => {
                    const now = new Date().getTime();
                    const timeDiff = now - lastTapRef.current;
                    if (timeDiff < 400 && timeDiff > 0) { tapCountRef.current++; } else { tapCountRef.current = 1; }
                    lastTapRef.current = now;
                    if (tapCountRef.current === 3) { callback(); tapCountRef.current = 0; }
                };

                const requestWakeLock = async () => {
                    if ('wakeLock' in navigator) {
                        try { const lock = await navigator.wakeLock.request('screen'); wakeLockRef.current = lock; } catch (err) { console.log("Wake Lock error:", err); }
                    }
                };

                const releaseWakeLock = async () => {
                    if (wakeLockRef.current) { try { await wakeLockRef.current.release(); wakeLockRef.current = null; } catch(err) {} }
                };

                const resetCard = () => {
                    setNoTransition(true); setCardSide(1); setRotation(0); cancelSpeech(); setViewAllSentences(false);
                    setTimeout(() => setNoTransition(false), 50); 
                };

                const handleNext = () => {
                    if (!currentWordIds.length || isFinished) return;
                    setViewAllSentences(false); cancelSpeech();
                    if (currentIndex >= currentWordIds.length - 1) {
                        setIsFinished(true); setNoTransition(true); setCardSide(1); setRotation(0); return;
                    }
                    setNoTransition(true); setCardSide(1); setRotation(0);
                    setTimeout(() => { setNoTransition(false); setCurrentIndex((prev) => prev + 1); }, 50);
                };

                const handlePrev = () => {
                    if (!currentWordIds.length || isFinished) return; 
                    setViewAllSentences(false); cancelSpeech();
                    setNoTransition(true); setCardSide(1); setRotation(0);
                    setTimeout(() => { setNoTransition(false); setCurrentIndex((prev) => (prev - 1 + currentWordIds.length) % currentWordIds.length); }, 50);
                };

                const handleReset = () => { setIsFinished(false); setCurrentIndex(0); resetCard(); };

                const handleCardClick = () => {
                    if (isFinished || (displayData && displayData.isEmpty)) return;
                    cancelSpeech();
                    if (cardSide === 1) { setCardSide(2); setRotation(180); }
                    else if (cardSide === 2) { setCardSide(1); setRotation(0); }
                    else if (cardSide === 3) { showTranslation(); }
                };

                const showSentences = (e) => { 
                    if(e) e.stopPropagation(); 
                    cancelSpeech();
                    setCardSide(3); setRotation(360); 
                };
                const showTranslation = (e) => { 
                    if(e) e.stopPropagation(); 
                    cancelSpeech();
                    setCardSide(2); setRotation(180); setViewAllSentences(false); 
                };

                const handleSpeak = (resume = false) => {
                    if (isFinished || !displayData || displayData.isEmpty) return;
                    
                    window.speechSynthesis.cancel();
                    requestWakeLock();
                    
                    setIsSpeaking(true);
                    setIsPaused(false);
                    pausedIntentionally.current = false;
                    
                    const cleanSentence = (txt) => txt.replace(/^\s*[0-9]+\.\s*/g, '').trim();
                    
                    // Definicja trybów mieszanych
                    const isMixedLangMode = tense === 'Początkujący' || tense === 'Beginner';
                    const targetWord = displayData.word ? displayData.word.split('(')[0].trim() : "";

                    let fullQueue = [];
                    
                    if (resume && queueRef.current.length > 0) {
                        fullQueue = queueRef.current;
                    } else {
                        if (viewAllSentences) setSpeakingSentenceIndex(0);
                        
                        let tempQueue = [];

                        // Funkcja pomocnicza do dzielenia zdań na PL/EN
                        const pushMixedSentence = (rawText, vIndex, gIndex) => {
                            let text = cleanSentence(rawText);
                            
                            // --- POPRAWKA: Usuń kropkę z końca zdania, aby lektor nie czytał "kropka" ---
                            text = text.replace(/\.$/, ''); 
                            // --------------------------------------------------------------------------

                            if (!targetWord || !isMixedLangMode) {
                                // Zwykły tryb - jeden język
                                tempQueue.push({ 
                                    text: text, 
                                    isSentence: true, 
                                    visualIndex: vIndex, 
                                    globalIndex: gIndex,
                                    lang: isMixedLangMode ? 'pl-PL' : 'en-US' 
                                });
                            } else {
                                // Tryb mieszany - rozbijamy zdanie
                                const escapedTarget = targetWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                const regex = new RegExp(`(${escapedTarget})`, 'gi');
                                const parts = text.split(regex);

                                parts.forEach(part => {
                                    if (!part.trim()) return;
                                    // Dodatkowe zabezpieczenie: jeśli część to same znaki interpunkcyjne, ignoruj
                                    if (/^[.,?!]+$/.test(part.trim())) return;

                                    const isEnWord = part.toLowerCase() === targetWord.toLowerCase();
                                    tempQueue.push({
                                        text: part,
                                        isSentence: true, 
                                        visualIndex: vIndex,
                                        globalIndex: gIndex,
                                        lang: isEnWord ? 'en-US' : 'pl-PL',
                                        forceVoice: isEnWord ? selectedVoice : selectedPlVoice
                                    });
                                });
                            }
                        };

                        if (cardSide === 3 && viewAllSentences) {
                            // CZYTANIE WSZYSTKICH ZDAŃ
                            let lastWord = "";
                            sentencesListToRender.forEach((s, index) => {
                                // Nagłówek słowa
                                if (s.word !== lastWord) {
                                    if (lastWord !== "") tempQueue.push({ text: "...", isPause: true, duration: 'long' }); 
                                    lastWord = s.word;
                                    tempQueue.push({ text: lastWord, isWord: true, globalIndex: index, lang: 'en-US' });
                                    tempQueue.push({ text: ".", isPause: true, duration: 'short' }); 
                                }
                                
                                // Zdanie (może być miksowane)
                                const rowTargetWord = s.word ? s.word.split('(')[0].trim() : "";
                                
                                if (isMixedLangMode && rowTargetWord) {
                                    let cText = cleanSentence(s.en);
                                    cText = cText.replace(/\.$/, ''); // Usuń kropkę tutaj też
                                    
                                    const escT = rowTargetWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                    const reg = new RegExp(`(${escT})`, 'gi');
                                    const pts = cText.split(reg);
                                    
                                    pts.forEach(pt => {
                                        if(!pt.trim()) return;
                                        if (/^[.,?!]+$/.test(pt.trim())) return; // Ignoruj interpunkcję

                                        const isEn = pt.toLowerCase() === rowTargetWord.toLowerCase();
                                        tempQueue.push({
                                            text: pt, isSentence: true, visualIndex: index, globalIndex: index,
                                            lang: isEn ? 'en-US' : 'pl-PL',
                                            forceVoice: isEn ? selectedVoice : selectedPlVoice
                                        });
                                    });
                                } else {
                                    pushMixedSentence(s.en, index, index);
                                }
                                
                                tempQueue.push({ text: "...", isPause: true, duration: 'medium' });
                            });

                        } else if (cardSide === 3) {
                            // CZYTANIE LISTY ZDAŃ DLA JEDNEGO SŁOWA
                            displayData.sentences.forEach((s, index) => {
                                pushMixedSentence(s.en, index);
                                tempQueue.push({ text: "...", isPause: true, duration: 'medium' });
                            });
                        } else {
                            // STRONA GŁÓWNA (AWERS/REWERS)
                            if (tense !== 'Base' && tense !== 'mixed' && displayData.sentences.length > 0) {
                                pushMixedSentence(displayData.sentences[0].en);
                            } else {
                                tempQueue.push({ text: displayData.word, lang: 'en-US' });
                            }
                        }
                        fullQueue = tempQueue;
                        queueRef.current = tempQueue;
                        queueIndexRef.current = 0;
                    }

                    if (fullQueue.length === 0) {
                        setIsSpeaking(false);
                        releaseWakeLock(); 
                        return;
                    }

                    const startIndex = resume ? queueIndexRef.current : 0;
                    const queueToSpeak = fullQueue.slice(startIndex);

                    if (queueToSpeak.length === 0) {
                        setIsSpeaking(false);
                        return;
                    }

                    queueToSpeak.forEach((item, i) => {
                        const u = new SpeechSynthesisUtterance(item.text);
                        
                        if (item.forceVoice) {
                            u.voice = item.forceVoice;
                            u.lang = item.lang;
                        } else if (item.lang) {
                            u.lang = item.lang;
                            if (item.lang === 'pl-PL' && selectedPlVoice) u.voice = selectedPlVoice;
                            if (item.lang === 'en-US' && selectedVoice) u.voice = selectedVoice;
                        } else {
                            if (isMixedLangMode) {
                                u.lang = 'pl-PL';
                                if (selectedPlVoice) u.voice = selectedPlVoice;
                            } else {
                                u.lang = 'en-US';
                                if (selectedVoice) u.voice = selectedVoice;
                            }
                        }

                        u.rate = 0.85;

                        if (item.isPause) {
                            u.text = " . . . "; 
                            u.volume = 0; 
                            if (item.duration === 'long') u.rate = 0.1;       
                            else if (item.duration === 'medium') u.rate = 0.3; 
                            else u.rate = 0.8;                               
                        }
                        
                        if (item.lang === 'en-US' && isMixedLangMode) {
                            u.rate = 0.7;
                        }

                        u.onstart = () => {
                            if (isPausedRef.current) return;
                            const actualGlobalIndex = startIndex + i;
                            queueIndexRef.current = actualGlobalIndex;

                            if (i === 0) setIsSpeaking(true);
                            
                            if (item.isSentence && item.visualIndex !== undefined) {
                                setActiveSentenceIndex(item.visualIndex); 
                                if (viewAllSentences && item.globalIndex !== undefined) {
                                    setSpeakingSentenceIndex(item.globalIndex);
                                }
                                const element = itemRefs.current[item.visualIndex];
                                if (element) element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            } else if (item.isWord) {
                                setActiveSentenceIndex(null); 
                                if (viewAllSentences && item.globalIndex !== undefined) {
                                    setSpeakingSentenceIndex(item.globalIndex);
                                }
                            }
                        };

                        if (i === queueToSpeak.length - 1) {
                            u.onend = () => {
                                if (!pausedIntentionally.current) {
                                    setIsSpeaking(false);
                                    setIsPaused(false);
                                    setActiveSentenceIndex(null); 
                                    releaseWakeLock();
                                }
                            };
                            u.onerror = (e) => {
                                if (!pausedIntentionally.current) {
                                    console.error("Speech error", e);
                                    setIsSpeaking(false);
                                    setIsPaused(false);
                                    releaseWakeLock(); 
                                }
                            };
                        }

                        window.speechSynthesis.speak(u);
                    });
                };

                const cancelSpeech = () => { 
                    isPausedRef.current = false;
                    pausedIntentionally.current = false;
                    if (window.speechSynthesis) window.speechSynthesis.cancel(); 
                    setIsSpeaking(false);
                    setIsPaused(false);
                    setActiveSentenceIndex(null); 
                    releaseWakeLock(); 
                };

                const togglePlayPause = (e) => {
                    if(e) e.stopPropagation();
                    if (isSpeaking && !isPaused) {
                        isPausedRef.current = true;
                        pausedIntentionally.current = true;
                        window.speechSynthesis.cancel();
                        setIsPaused(true);
                    } else if (isPaused) {
                        isPausedRef.current = false;
                        handleSpeak(true);
                    } else {
                        isPausedRef.current = false;
                        handleSpeak(false);
                    }
                };

                const handleBottomBtnClick = () => {
                    if (cardSide === 3) {
                        togglePlayPause();
                    } else {
                        handleSpeak(false);
                    }
                };

                const highlightTargetWord = (sentence, targetWord) => {
                    if (!targetWord) return sentence;
                    const cleanTarget = targetWord.split('(')[0].trim();
                    const escapedTarget = cleanTarget.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(${escapedTarget})`, 'gi');
                    const parts = sentence.split(regex);
                    return parts.map((part, index) => 
                        part.toLowerCase() === cleanTarget.toLowerCase() 
                        ? <span key={index} className={`${isDarkMode ? 'text-red-400' : 'text-red-600'} font-extrabold text-xl sm:text-2xl`}>{part}</span> 
                        : part
                    );
                };

                const theme = isDarkMode ? {
                    bg: 'bg-gray-900', text: 'text-gray-100', headerText: 'text-indigo-400',
                    cardFrontBg: 'bg-gray-800', cardFrontText: 'text-white', cardBorder: 'border-gray-700',
                    cardBackBg: 'bg-indigo-900', controlsBg: 'bg-gray-800', controlsBorder: 'border-gray-700',
                    selectText: 'text-indigo-300', subText: 'text-gray-400', counterBg: 'bg-gray-800',
                    counterText: 'text-indigo-300', buttonBg: 'bg-gray-800', buttonHover: 'hover:bg-gray-700',
                    buttonText: 'text-gray-200', accent: 'bg-indigo-800 text-indigo-200'
                } : {
                    bg: 'bg-gradient-to-br from-blue-50 to-indigo-100', text: 'text-gray-800', headerText: 'text-indigo-700',
                    cardFrontBg: 'bg-white', cardFrontText: 'text-gray-800', cardBorder: 'border-indigo-200',
                    cardBackBg: 'bg-indigo-600', controlsBg: 'bg-white', controlsBorder: 'border-indigo-200',
                    selectText: 'text-indigo-700', subText: 'text-gray-500', counterBg: 'bg-white/50',
                    counterText: 'text-indigo-800', buttonBg: 'bg-white', buttonHover: 'hover:bg-gray-50',
                    buttonText: 'text-gray-700', accent: 'bg-indigo-100 text-indigo-500'
                };

                if (loading) return <div className={`h-[100dvh] flex flex-col items-center justify-center p-4 ${theme.bg} ${theme.text}`}><div className="text-4xl mb-4 animate-spin text-indigo-500"><Icon path={iconPaths.layers} size={48} /></div><div className="text-lg font-semibold">Wczytywanie bazy słów...</div></div>;
                if (fileError) return <div className={`h-[100dvh] flex flex-col items-center justify-center p-8 ${theme.bg} ${theme.text} text-center`}><div className="text-4xl mb-4">⚠️</div><div className="text-xl font-bold mb-4 text-red-500">Problem z bazą danych</div><pre className="mb-6 text-sm bg-red-50 p-4 rounded text-left overflow-auto max-w-full whitespace-pre-wrap">{fileError}</pre><button onClick={() => location.reload()} className="bg-red-600 text-white px-6 py-2 rounded-lg">Odśwież stronę</button></div>;

                return (
                    <div className={`h-[100dvh] flex flex-col items-center pt-1 pb-[5dvh] px-4 font-sans transition-colors-all duration-700 ${theme.bg} ${theme.text} relative overflow-hidden noselect`}>
                        {oledMode && (<div className="fixed inset-0 bg-black z-[99999] cursor-pointer" onClick={() => handleTripleTap(() => setOledMode(false))}></div>)}
                        
                        {/* --- POZIOMY MODAL PEŁNOEKRANOWY --- */}
                        {isLevelModalOpen && (
                            <div className={`fixed inset-0 z-[9999] flex flex-col transition-all animate-slideIn ${isDarkMode ? 'bg-gray-900' : 'bg-white'}`}>
                                <div className={`p-4 border-b flex justify-between items-center flex-none shadow-sm ${isDarkMode ? 'border-gray-800 bg-gray-900' : 'border-gray-100 bg-white'}`}>
                                    <h3 className="text-xl font-bold flex items-center gap-2"><Icon path={iconPaths.barChart} size={24}/> Wybierz poziom</h3>
                                    <button onClick={closeLevelModal} className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"><Icon path={iconPaths.close} size={28}/></button>
                                </div>
                                <div className="p-3 bg-blue-50 dark:bg-blue-900/20 text-blue-800 dark:text-blue-200 text-xs sm:text-sm text-center font-medium border-b border-blue-100 dark:border-blue-900/30">
                                    Kliknij <strong>nazwę</strong>, aby wybrać jeden.<br/>
                                    Kliknij <strong>kwadracik</strong>, aby zaznaczyć wiele.
                                </div>
                                <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
                                    <div className="flex flex-col gap-3">
                                        {availableLevels.map(lvl => {
                                            const isSelected = tempSelectedLevels.includes(lvl);
                                            return (
                                                <div 
                                                    key={lvl} 
                                                    className={`
                                                        flex items-center justify-between p-4 rounded-xl border-2 transition-all duration-150 select-none
                                                        ${isSelected 
                                                            ? 'item-multi-selected' 
                                                            : (isDarkMode ? 'bg-gray-800 border-gray-700 text-gray-300' : 'bg-gray-50 border-gray-200 text-gray-700')
                                                        }
                                                    `}
                                                >
                                                    <div className="flex-1 py-2 font-bold text-2xl active:scale-95 transition-transform cursor-pointer" onClick={() => handleSingleSelectLevel(lvl)}>
                                                        {lvl}
                                                    </div>
                                                    <div className="pl-4 py-2 cursor-pointer active:scale-90 transition-transform text-gray-400 hover:text-emerald-500" onClick={(e) => handleMultiToggleLevel(e, lvl)}>
                                                        {isSelected 
                                                            ? <div className="text-emerald-500"><Icon path={iconPaths.checkSquare} size={32} /></div>
                                                            : <Icon path={iconPaths.square} size={32} />
                                                        }
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                {tempSelectedLevels.length > 0 && (
                                    <div className={`p-4 border-t flex-none z-10 animate-slideUp ${isDarkMode ? 'bg-gray-900 border-gray-800' : 'bg-white border-gray-100'}`}>
                                        <button onClick={confirmMultiLevelSelection} className="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-4 rounded-xl shadow-lg active:scale-95 transition-all text-lg flex items-center justify-center gap-2">
                                            <Icon path={iconPaths.check} /> Zatwierdź poziomy ({tempSelectedLevels.length})
                                        </button>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* --- KATEGORIE MODAL PEŁNOEKRANOWY --- */}
                        {isCategoryModalOpen && (
                            <div className={`fixed inset-0 z-[9999] flex flex-col transition-all animate-slideIn ${isDarkMode ? 'bg-gray-900' : 'bg-white'}`}>
                                <div className={`p-4 border-b flex justify-between items-center flex-none shadow-sm ${isDarkMode ? 'border-gray-800 bg-gray-900' : 'border-gray-100 bg-white'}`}>
                                    <h3 className="text-xl font-bold flex items-center gap-2"><Icon path={iconPaths.filter} size={24}/> Wybierz temat</h3>
                                    <button onClick={closeCategoryModal} className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"><Icon path={iconPaths.close} size={28}/></button>
                                </div>
                                <div className="p-3 bg-blue-50 dark:bg-blue-900/20 text-blue-800 dark:text-blue-200 text-xs sm:text-sm text-center font-medium border-b border-blue-100 dark:border-blue-900/30">
                                    Kliknij <strong>nazwę</strong>, aby wybrać jeden.<br/>
                                    Kliknij <strong>kwadracik</strong>, aby zaznaczyć wiele.
                                </div>
                                <div className="flex-1 overflow-y-auto p-2 sm:p-4 custom-scrollbar">
                                    <div className="flex flex-col gap-2 pb-20">
                                        {availableCategories.map(cat => {
                                            const isSelected = tempSelectedCategories.includes(cat);
                                            return (
                                                <div 
                                                    key={cat} 
                                                    className={`
                                                        flex items-center justify-between p-3 rounded-xl border-2 transition-all duration-150 select-none
                                                        ${isSelected 
                                                            ? 'item-multi-selected' 
                                                            : (isDarkMode ? 'bg-gray-800 border-gray-700 text-gray-300' : 'bg-gray-50 border-gray-200 text-gray-700')
                                                        }
                                                    `}
                                                >
                                                    <div className="flex-1 py-2 font-bold text-lg active:scale-95 transition-transform cursor-pointer" onClick={() => handleSingleSelectCategory(cat)}>
                                                        {cat}
                                                    </div>
                                                    <div className="pl-4 py-2 cursor-pointer active:scale-90 transition-transform text-gray-400 hover:text-emerald-500" onClick={(e) => handleMultiToggleCategory(e, cat)}>
                                                        {isSelected 
                                                            ? <div className="text-emerald-500"><Icon path={iconPaths.checkSquare} size={32} /></div>
                                                            : <Icon path={iconPaths.square} size={32} />
                                                        }
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                {tempSelectedCategories.length > 0 && (
                                    <div className={`p-4 border-t flex-none z-10 animate-slideUp ${isDarkMode ? 'bg-gray-900 border-gray-800' : 'bg-white border-gray-100'}`}>
                                        <button onClick={confirmMultiCategorySelection} className="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-4 rounded-xl shadow-lg active:scale-95 transition-all text-lg flex items-center justify-center gap-2">
                                            <Icon path={iconPaths.check} /> Zatwierdź wybrane ({tempSelectedCategories.length})
                                        </button>
                                    </div>
                                )}
                            </div>
                        )}
                        {/* --- KONIEC MODALI --- */}

                        <header className="w-full max-w-lg flex-none flex flex-col items-center space-y-3 mt-0 mb-2">
                            <div className="w-full relative flex items-center justify-center min-h-[48px]">
                                <div className="absolute left-0">
                                    <button onClick={() => setIsDarkMode(!isDarkMode)} className={`p-2 rounded-full shadow-md transition-colors-all duration-700 ${isDarkMode ? 'bg-gray-800 text-yellow-400 hover:bg-gray-700' : 'bg-white text-indigo-600 hover:bg-gray-50'}`}><div className={isStartAnimating ? "startup-anim" : ""}><Icon path={isDarkMode ? iconPaths.sun : iconPaths.moon} size={20} className="sm:w-6 sm:h-6" /></div></button>
                                </div>
                                <h1 onClick={() => handleTripleTap(() => setOledMode(true))} className={`text-xl sm:text-3xl font-extrabold flex items-center gap-2 ${theme.headerText} text-center transition-colors-all duration-700 cursor-pointer select-none active:scale-95`}><Icon path={iconPaths.layers} size={24} className="sm:w-8 sm:h-8" /> Fiszki WOJTUKIEWICZ</h1>
                            </div>
                            <div className="w-full grid grid-cols-2 gap-2 sm:gap-3">
                                
                                {/* PRZYCISK POZIOMY */}
                                <div onClick={openLevelModal} className={`${theme.controlsBg} px-3 py-2 rounded-xl shadow-md border-l-4 ${selectedLevels.length > 0 ? 'border-indigo-500' : 'border-indigo-400'} flex flex-col justify-center transition-colors-all duration-700 cursor-pointer active:scale-95 hover:opacity-90`}>
                                    <label className={`text-[10px] sm:text-xs font-bold uppercase block mb-0.5 sm:mb-1 ${theme.subText} transition-colors-all duration-700`}>Poziom</label>
                                    <div className={`w-full bg-transparent font-bold text-sm sm:text-base whitespace-nowrap overflow-hidden text-ellipsis ${theme.selectText}`}>
                                        {getLevelLabel()}
                                    </div>
                                </div>
                                
                                {/* PRZYCISK TEMATY */}
                                <div onClick={openCategoryModal} className={`${theme.controlsBg} px-3 py-2 rounded-xl shadow-md border-l-4 ${selectedCategories.length > 0 ? 'border-emerald-500' : (isDarkMode ? 'border-indigo-600' : 'border-indigo-400')} flex flex-col justify-center transition-colors-all duration-700 cursor-pointer active:scale-95 hover:opacity-90`}>
                                    <label className={`text-[10px] sm:text-xs font-bold uppercase mb-0.5 sm:mb-1 flex items-center gap-1 ${theme.subText} transition-colors-all duration-700`}><Icon path={iconPaths.tag} size={10} className="sm:w-3 sm:h-3"/> Temat</label>
                                    <div className={`w-full bg-transparent font-bold text-sm sm:text-base whitespace-nowrap overflow-hidden text-ellipsis ${theme.selectText}`}>
                                        {getCategoryLabel()}
                                    </div>
                                </div>

                            </div>
                            <div className={`${theme.counterBg} px-3 py-1.5 sm:py-2 rounded-lg sm:rounded-xl text-xs sm:text-sm border border-white/10 font-semibold whitespace-nowrap ${theme.counterText} transition-colors-all duration-700 w-full sm:w-auto text-center mt-2`}>
                                {viewAllSentences && sentencesListToRender.length > 0 ? (() => { const currentS = sentencesListToRender[speakingSentenceIndex]; const currentWordNum = currentS ? currentS.wordIndex + 1 : 1; return `Słowo: ${currentWordNum} / ${currentWordIds.length}`; })() : (currentWordIds.length > 0 ? `${isFinished ? currentWordIds.length : currentIndex + 1} / ${currentWordIds.length}` : '0 / 0')}
                            </div>
                        </header>

                        {isFinished ? (
                                <div className="w-full max-w-md flex-1 min-h-[250px] mb-4 z-10 flex flex-col items-center justify-center animate-popIn">
                                <div className={`w-full p-8 rounded-3xl shadow-2xl flex flex-col items-center justify-center text-center ${theme.cardFrontBg} ${isDarkMode ? 'border border-gray-700' : ''} transition-colors-all duration-700`}>
                                    <div className={`mb-6 p-6 rounded-full ${isDarkMode ? 'bg-yellow-500/20' : 'bg-yellow-100'} transition-colors-all duration-700`}><Icon path={iconPaths.trophy} size={64} className="text-yellow-500" /></div>
                                    <h2 className={`text-3xl font-black mb-2 ${theme.cardFrontText} transition-colors-all duration-700`}>Gratulacje!</h2>
                                    <p className={`text-lg mb-8 ${theme.subText} transition-colors-all duration-700`}>Brawo, skończyłeś całą kategorię!</p>
                                    <button onClick={handleReset} className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-8 rounded-xl shadow-lg active:scale-95 transition-all text-lg flex items-center gap-2"><Icon path={iconPaths.rotate} size={24} /> Zacznij od nowa</button>
                                </div>
                                </div>
                        ) : (
                            <>
                                <div className="relative w-full max-w-md flex-1 min-h-[250px] mb-4 z-10 perspective-1000">
                                    <div className={`relative w-full h-full shadow-2xl rounded-2xl cursor-pointer transform-style-3d ${noTransition ? '' : 'transition-transform duration-700 ease-in-out'}`} style={{ transform: `rotateY(${rotation}deg)` }} onClick={handleCardClick} onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd} onMouseDown={onMouseDown} onMouseMove={onMouseMove} onMouseUp={onMouseUp} onMouseLeave={onMouseLeave}>
                                        <div className={`absolute inset-0 w-full h-full rounded-2xl flex flex-col items-center justify-center p-4 sm:p-6 backface-hidden border-b-4 ${theme.cardFrontBg} ${isDarkMode ? 'border-gray-600' : 'border-indigo-200'} transition-colors-all duration-700`} style={{ transform: 'rotateY(0deg)' }}>
                                            {cardSide === 3 ? (
                                                <div className="w-full h-full flex flex-col animate-fadeIn">
                                                    <div className="flex justify-between items-center mb-2 sm:mb-3 border-b pb-2 border-gray-200/20 flex-none relative">
                                                        <h3 className={`font-bold flex items-center gap-2 text-sm sm:text-base ${isDarkMode ? 'text-indigo-300' : 'text-indigo-600'} transition-colors-all duration-700`}><Icon path={iconPaths.book} size={16} className="sm:w-[18px] sm:h-[18px]"/> Zdania</h3>
                                                        <button onClick={(e) => { e.stopPropagation(); setViewAllSentences(!viewAllSentences); }} className={`mx-auto flex items-center gap-2 px-3 py-1 rounded-full hover:bg-black/5 active:scale-95 transition-all ${viewAllSentences ? 'text-emerald-500' : 'text-indigo-400'}`} title={viewAllSentences ? "Pokaż tylko dla tego słowa" : "Wczytaj wszystkie zdania z tej kategorii"}>
                                                            <div className={viewAllSentences ? "" : "animate-spin-three"}><Icon path={iconPaths.reloadCustom} size={20} className="sm:w-6 sm:h-6" /></div><span className="text-xs sm:text-sm font-bold uppercase whitespace-nowrap">All words</span>
                                                        </button>
                                                        <div className="flex items-center" onClick={(e) => e.stopPropagation()}>
                                                            <div className={`px-2 py-1 rounded-lg border flex items-center gap-1 ${isDarkMode ? "bg-gray-700 border-gray-600" : "bg-gray-100 border-gray-300"} transition-colors-all duration-700`}>
                                                                <Icon path={iconPaths.clock} size={12} className={`${isDarkMode ? "text-gray-400" : "text-indigo-500"} transition-colors-all duration-700`}/><select value={tense} onChange={(e) => setTense(e.target.value)} className={`bg-transparent text-xs font-bold outline-none w-[110px] sm:w-[150px] ${isDarkMode ? 'text-gray-200' : 'text-gray-800'} transition-colors-all duration-700`}><option value="Base" className={isDarkMode ? "bg-gray-700 text-white" : "bg-white text-gray-900"}>Wybierz czas</option>{availableTenses.map(t => (<option key={t} value={t} className={isDarkMode ? "bg-gray-700 text-white" : "bg-white text-gray-900"}>{t}</option>))}<option value="mixed" className={isDarkMode ? "bg-gray-700 text-white" : "bg-white text-gray-900"}>Mix czasów</option></select>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <ul className="space-y-3 sm:space-y-4 text-base sm:text-lg text-left overflow-y-auto pr-1 custom-scrollbar flex-1 pb-20">{sentencesListToRender.length > 0 ? sentencesListToRender.map((s, i) => (<li key={i} ref={el => itemRefs.current[i] = el} className={`flex flex-col gap-1 transition-transform duration-300 origin-left pl-1 ${activeSentenceIndex === i ? 'scale-110 z-10' : 'scale-100 z-0'}`}><div className="flex gap-2 leading-snug"><span className={`${isDarkMode ? 'text-gray-200' : 'text-gray-700'} transition-colors-all duration-700`}>{highlightTargetWord(s.en, viewAllSentences ? s.word : (displayData ? displayData.word : ''))}</span></div>{s.pl && tense !== 'Beginner' && (<div className={`pl-6 text-sm sm:text-base italic ${theme.subText} transition-colors-all duration-700`}>({s.pl})</div>)}</li>)) : <li className="text-center opacity-50 italic mt-4">Brak przykładowych zdań dla tego czasu</li>}</ul>
                                                    <div className={`mt-2 text-center font-mono text-lg sm:text-xl font-bold opacity-80 ${theme.subText} transition-colors-all duration-700`}>
                                                        {currentPhoneticToDisplay}
                                                    </div>
                                                </div>
                                            ) : (
                                                <>
                                                    <div className={`absolute top-4 left-4 sm:top-6 sm:left-6 text-[10px] sm:text-xs font-bold uppercase flex flex-wrap items-center gap-1 sm:gap-2 max-w-full overflow-hidden ${theme.subText} transition-colors-all duration-700`}><span className="truncate max-w-[80px] sm:max-w-none">{tense === 'mixed' ? 'Mix' : (tense === 'Base' ? 'Słowo En.' : tense)}</span></div>
                                                    
                                                    {/* PRZYCISK ZMIANY JĘZYKA */}
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); setIsPlToEn(!isPlToEn); }}
                                                        className={`absolute top-4 right-4 sm:top-6 sm:right-6 px-3 py-1 rounded-lg text-[10px] sm:text-xs font-bold border transition-all active:scale-95 flex items-center gap-1 ${isDarkMode ? 'border-indigo-500 text-indigo-300 hover:bg-gray-700' : 'border-indigo-300 text-indigo-600 hover:bg-indigo-50'}`}
                                                    >
                                                    <Icon path={iconPaths.swap} size={14} className="sm:w-4 sm:h-4"/> {isPlToEn ? "PL ➔ EN" : "EN ➔ PL"}
                                                    </button>

                                                    <div className="flex-1 flex items-center justify-center w-full px-2">
                                                        <h2 className={`${getWordSizeClass(isPlToEn ? (displayData ? displayData.translation : '') : (displayData ? displayData.word : ''))} font-black text-center break-words leading-tight ${theme.cardFrontText} transition-colors-all duration-700`}>
                                                            {displayData ? (isPlToEn ? displayData.translation : displayData.word) : 'Loading...'}
                                                        </h2>
                                                    </div>
                                                    <div className={`absolute bottom-4 sm:bottom-6 text-[10px] sm:text-xs flex items-center gap-1 sm:gap-2 font-medium ${theme.subText} transition-colors-all duration-700`}><Icon path={iconPaths.rotate} size={12} className="sm:w-[14px] sm:h-[14px]"/> Kliknij, aby obrócić</div>
                                                </>
                                            )}
                                        </div>
                                        <div className={`absolute inset-0 w-full h-full text-white rounded-2xl flex flex-col items-center justify-center p-4 sm:p-6 backface-hidden border-b-4 ${theme.cardBackBg} ${isDarkMode ? 'border-indigo-950' : 'border-indigo-800'} transition-colors-all duration-700`} style={{ transform: 'rotateY(180deg)' }}>
                                            <div className="absolute top-4 right-4 sm:top-6 sm:right-6 text-[10px] sm:text-xs font-bold text-indigo-200 uppercase">
                                                {isPlToEn ? "Po angielsku" : "Tłumaczenie"}
                                            </div>
                                            <h2 className={`${getTranslationSizeClass(isPlToEn ? (displayData ? displayData.word : '') : (displayData ? displayData.translation : ''))} font-bold mb-3 sm:mb-4 text-center leading-tight break-words max-w-full`}>
                                                {displayData ? (isPlToEn ? displayData.word : displayData.translation) : ''}
                                            </h2>
                                            <div className={`bg-white/20 px-5 sm:px-7 py-2 sm:py-3 rounded-full font-mono ${getPhoneticSizeClass(displayData ? displayData.phonetic : '')} mb-8 sm:mb-10`}>{displayData ? displayData.phonetic : ''}</div>
                                            <button onClick={showSentences} className={`font-bold py-2 sm:py-3 px-4 sm:px-6 rounded-xl shadow-lg active:scale-95 flex items-center gap-2 text-sm sm:text-base transition-colors ${isDarkMode ? 'bg-gray-800 text-white hover:bg-gray-700' : 'bg-white text-indigo-700 hover:bg-indigo-50'}`}><Icon path={iconPaths.book} size={18} className="sm:w-5 sm:h-5"/> {tense === 'Base' ? 'Zdania (Base)' : `Zdania (${tense})`}</button>
                                        </div>
                                    </div>
                                </div>
                                <div className="w-full max-w-md flex-none space-y-3 z-20 mb-2">
                                    <div className="grid grid-cols-2 gap-3">
                                        <button onClick={handlePrev} className={`${theme.buttonBg} ${theme.buttonHover} ${theme.buttonText} font-bold py-4 rounded-xl shadow-sm border ${theme.controlsBorder} flex justify-center gap-2 active:scale-95 transition-colors-all duration-700 text-sm`}><Icon path={iconPaths.left} className="w-5 h-5" /> Poprzednia</button>
                                        <button onClick={handleNext} className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 rounded-xl shadow-lg flex justify-center gap-2 active:scale-95 transition-colors duration-300 text-sm">Następna <Icon path={iconPaths.right} className="w-5 h-5" /></button>
                                    </div>
                                    <button 
                                        onClick={handleBottomBtnClick} 
                                        className={`w-full text-lg font-bold py-4 rounded-xl shadow-xl active:scale-95 flex justify-center gap-3 border-b-4 transition-colors duration-300 ${isSpeaking && !isPaused ? "bg-emerald-400 border-emerald-600" : "bg-emerald-500 hover:bg-emerald-600 border-emerald-700 text-white"}`}
                                    >
                                        {cardSide === 3 
                                            ? (
                                                <>
                                                    {isSpeaking && !isPaused ? <Icon path={iconPaths.pause} size={24} className="sm:w-6 sm:h-6"/> : <Icon path={iconPaths.play} size={24} className="sm:w-6 sm:h-6"/>}
                                                    {isSpeaking && !isPaused ? "Pauza" : (isPaused ? "Wznów" : "Czytaj zdania")}
                                                </>
                                            ) 
                                            : (
                                                <>
                                                    {isSpeaking ? <Icon path={iconPaths.volX} size={24} className="sm:w-6 sm:h-6"/> : <Icon path={iconPaths.vol} size={24} className="sm:w-6 sm:h-6"/>}
                                                    {isSpeaking ? "Odtwarzanie..." : "Czytaj wymowę"}
                                                </>
                                            )
                                        }
                                    </button>
                                </div>
                            </>
                        )}
                    </div>
                );
            }
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<FlashcardsApp />);
        } catch (err) { document.getElementById('error-overlay').style.display = 'flex'; document.getElementById('error-message').textContent = err.toString(); }
    </script>
</body>
</html>
