<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fiszki Master 3D (Excel)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

    <style>
        .perspective-1000 { perspective: 1000px; }
        .transform-style-3d { transform-style: preserve-3d; }
        .backface-hidden { backface-visibility: hidden; -webkit-backface-visibility: hidden; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fadeIn { animation: fadeIn 0.4s ease-in-out; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 4px; }
        #error-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.98); z-index: 9999; flex-direction: column; align-items: center; justify-content: center; color: #991b1b; padding: 20px; text-align: center; }
        .no-tap-highlight { -webkit-tap-highlight-color: transparent; }
        .transition-colors-all { transition-property: background-color, border-color, color, fill, stroke; transition-duration: 300ms; }
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="m-0 transition-colors duration-300 no-tap-highlight overflow-hidden">

    <div id="error-overlay">
        <h2 class="text-2xl font-bold mb-2">Wystąpił błąd</h2>
        <p class="mb-4 text-gray-600">Nie udało się załadować bazy danych Excel.</p>
        <div id="local-file-warning" class="hidden mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg text-yellow-800 text-sm max-w-md text-left">
            <strong>⚠️ Wykryto uruchomienie lokalne (file://)</strong><br/><br/>
            Przeglądarki mogą blokować wczytywanie pliku <code>bazaA1.xlsx</code> z dysku ze względów bezpieczeństwa (CORS).<br/>
            Aby to działało lokalnie, najlepiej uruchomić prosty serwer (np. Live Server w VS Code) lub użyć flag przeglądarki.
        </div>
        <pre id="error-message" class="bg-red-100 p-4 rounded text-sm text-left overflow-auto max-w-full max-h-64 select-text"></pre>
        <button onclick="location.reload()" class="bg-red-600 text-white px-6 py-3 rounded-xl font-bold shadow-lg hover:bg-red-700 transition mt-4">Spróbuj ponownie</button>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line, col, error) {
            document.getElementById('error-overlay').style.display = 'flex';
            document.getElementById('error-message').textContent = `JS Error: ${msg}\nLine: ${line}`;
            if (window.location.protocol === 'file:') {
                document.getElementById('local-file-warning').style.display = 'block';
            }
            return false;
        };
    </script>

    <script type="text/babel">
        try {
            const { useState, useEffect, useMemo } = React;

            const Icon = ({ path, size = 24, className="" }) => (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
            );

            const iconPaths = {
                layers: <><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></>,
                book: <><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></>,
                rotate: <><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></>,
                left: <><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></>,
                right: <><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></>,
                vol: <><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></>,
                volX: <><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></>,
                tag: <><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></>,
                clock: <><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></>,
                hash: <><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></>,
                moon: <><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></>,
                sun: <><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></>,
                close: <><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>
            };

            const categoryMapping = {
                "Rodzina": "Ludzie", "Ludzie": "Ludzie", "Zawód": "Ludzie", "Mężczyźni": "Ludzie", "Kobiety": "Ludzie", "Osoba": "Ludzie",
                "Części ciała": "Zdrowie i Ciało", "Zdrowie": "Zdrowie i Ciało",
                "Dom": "Dom i Otoczenie", "Mebel": "Dom i Otoczenie", "Budynki": "Dom i Otoczenie", "Miejsca": "Dom i Otoczenie",
                "Jedzenie": "Jedzenie",
                "Ubrania": "Rzeczy", "Przedmioty": "Rzeczy", "Rzeczowniki": "Rzeczy", "Technologia": "Rzeczy", "Zabawki": "Rzeczy", "Pieniądze": "Rzeczy",
                "Podróże": "Podróże i Transport", "Transport": "Podróże i Transport", "Kierunki": "Podróże i Transport",
                "Natura": "Natura i Świat", "Pogoda": "Natura i Świat", "Zwierzęta": "Natura i Świat",
                "Edukacja": "Edukacja i Praca", "Praca": "Edukacja i Praca",
                "Czas": "Czas i Liczby", "Liczby": "Czas i Liczby", "Liczebniki": "Czas i Liczby", "Ilość": "Czas i Liczby",
                "Czynności": "Czynności", "Myślenie": "Czynności", "Dźwięk": "Czynności",
                "Przymiotniki": "Cechy i Opis", "Kolory": "Cechy i Opis", "Emocje": "Cechy i Opis",
                "Sztuka": "Kultura i Hobby", "Sport": "Kultura i Hobby", "Muzyka": "Kultura i Hobby",
                "Gramatyka": "Gramatyka", "Spójniki": "Gramatyka", "Przedimki": "Gramatyka", "Czasowniki": "Gramatyka",
                "Zaimki": "Zaimki",
                "Przyimki": "Przyimki",
                "Przysłówki": "Przysłówki",
                "Pytania": "Komunikacja", "Zwroty": "Komunikacja", "Inne": "Komunikacja", "Pojęcia": "Komunikacja", "Słowo": "Komunikacja", "Historia": "Komunikacja"
            };

            function FlashcardsApp() {
                const [fullDatabase, setFullDatabase] = useState([]);
                const [loading, setLoading] = useState(true);
                const [fileError, setFileError] = useState(null);

                const [level, setLevel] = useState('A1');
                const [category, setCategory] = useState('all');
                
                const [tense, setTense] = useState('Base');
                
                const [availableCategories, setAvailableCategories] = useState([]);
                const [currentWordIds, setCurrentWordIds] = useState([]);
                const [currentIndex, setCurrentIndex] = useState(0);
                
                const [cardSide, setCardSide] = useState(1);
                const [rotation, setRotation] = useState(0);
                const [noTransition, setNoTransition] = useState(false);
                const [isSpeaking, setIsSpeaking] = useState(false);
                const [isDarkMode, setIsDarkMode] = useState(false);

                const [touchStart, setTouchStart] = useState(null);
                const [touchEnd, setTouchEnd] = useState(null);
                const minSwipeDistance = 50;

                // NOWA FUNKCJA WCZYTUJĄCA EXCEL
                useEffect(() => {
                    setLoading(true);
                    const excelUrl = `bazaA1.xlsx?t=${new Date().getTime()}`;
                    
                    fetch(excelUrl)
                        .then(res => {
                            if (!res.ok) throw new Error(`Błąd sieci: ${res.status} ${res.statusText}`);
                            return res.arrayBuffer();
                        })
                        .then(ab => {
                            // Parsowanie pliku Excel
                            const workbook = XLSX.read(ab, { type: 'array' });
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);

                            if (jsonData && jsonData.length > 0) {
                                // Transformacja danych z Excela ("Szeroki" format) na format aplikacji ("Długi" format)
                                // Kolumny z czasami w Excelu:
                                const tenseColumns = [
                                    "Present Simple", "Present continuous", "Past Simple", 
                                    "Future Simple", "Present Perfect", "Past Continuous", "Going To"
                                ];

                                const processedData = [];

                                jsonData.forEach(row => {
                                    // Pobranie i oczyszczenie podstawowych danych
                                    const id = row.id;
                                    const rawLevel = row.level ? String(row.level).trim() : "A1";
                                    const rawCat = row.category ? String(row.category).trim() : "Inne";
                                    const mappedCat = categoryMapping[rawCat] || rawCat;
                                    const word = row.word ? String(row.word).trim() : "";
                                    const translation = row.translation ? String(row.translation).trim() : "";
                                    const phonetic = row.phonetic ? String(row.phonetic).trim() : "";
                                    const baseForm = row.base ? String(row.base).trim() : word;

                                    // 1. Dodaj wpis BAZOWY (dla karty głównej)
                                    processedData.push({
                                        id: id,
                                        level: rawLevel,
                                        category: mappedCat,
                                        word: word,
                                        translation: translation,
                                        phonetic: phonetic,
                                        tense: 'Base'
                                    });

                                    // 2. Dodaj wpisy dla CZASÓW (jeśli kolumna w Excelu nie jest pusta)
                                    tenseColumns.forEach(tenseName => {
                                        if (row[tenseName]) {
                                            const content = String(row[tenseName]).trim();
                                            if (content) {
                                                processedData.push({
                                                    id: id,
                                                    level: rawLevel,
                                                    category: mappedCat,
                                                    word: word, // Główne słowo
                                                    translation: translation,
                                                    phonetic: phonetic,
                                                    tense: tenseName,
                                                    // Traktujemy zawartość komórki czasu jako pierwsze zdanie (s1)
                                                    s1: content,
                                                    conjugation: content // Opcjonalnie używane do podświetlania
                                                });
                                            }
                                        }
                                    });
                                });

                                setFullDatabase(processedData);
                                setLoading(false);
                            } else {
                                setFileError("Plik Excel wygląda na pusty.");
                                setLoading(false);
                            }
                        })
                        .catch(err => {
                            console.error(err);
                            setFileError(`Błąd wczytywania Excela: ${err.message}. Upewnij się, że plik 'bazaA1.xlsx' jest w tym samym folderze.`);
                            setLoading(false);
                        });
                }, []);

                useEffect(() => {
                    if (!fullDatabase.length) {
                        setAvailableCategories([]);
                        return;
                    }
                    const levelData = fullDatabase.filter(row => row.level === level);
                    const cats = [...new Set(levelData.map(row => row.category))].sort();
                    setAvailableCategories(cats);
                    setCategory('all');
                }, [level, fullDatabase]);

                useEffect(() => {
                    if (!fullDatabase.length) return;
                    // Pobieramy unikalne ID, które spełniają kryteria
                    const uniqueIds = [...new Set(
                        fullDatabase
                            .filter(row => {
                                const levelMatch = row.level === level;
                                const catMatch = category === 'all' ? true : row.category === category;
                                return levelMatch && catMatch;
                            })
                            .map(row => row.id)
                    )];
                    
                    const shuffledIds = [...uniqueIds].sort(() => Math.random() - 0.5);
                    setCurrentWordIds(shuffledIds);
                    setCurrentIndex(0);
                    resetCard();
                }, [category, level, fullDatabase]);

                // Reset czasu na 'Base' przy zmianie karty
                useEffect(() => {
                    setTense('Base');
                }, [currentIndex, currentWordIds]);

                const parseSentenceRow = (text) => {
                    if (!text) return null;
                    // Sprawdzamy czy jest nawias otwierający dla tłumaczenia
                    const lastParenIndex = text.lastIndexOf('(');
                    if (lastParenIndex === -1) return { en: text.trim(), pl: '' };
                    
                    const en = text.substring(0, lastParenIndex).trim();
                    const pl = text.substring(lastParenIndex + 1, text.length - 1).trim(); 
                    return { en, pl };
                };

                // Sprawdź, jakie czasy są dostępne dla tego słowa (oprócz Base)
                const availableTenses = useMemo(() => {
                      if (!currentWordIds.length || !fullDatabase.length) return [];
                      const currentId = currentWordIds[currentIndex];
                      const rows = fullDatabase.filter(row => row.id === currentId);
                      // Filtrujemy, żeby nie pokazywać pustych, ani 'Base' na liście wyboru
                      const tenses = rows.map(r => r.tense).filter(t => t && t !== 'Base');
                      return [...new Set(tenses)];
                }, [currentWordIds, currentIndex, fullDatabase]);

                const getDisplayData = () => {
                    if (!currentWordIds.length || !fullDatabase.length) return null;
                    const currentId = currentWordIds[currentIndex];
                    
                    // 1. Zawsze znajdujemy wiersz BAZOWY dla tłumaczenia i fonetyki
                    const baseRow = fullDatabase.find(row => row.id === currentId && row.tense === 'Base');
                    
                    // Jeśli nie ma Base, bierzemy pierwszy z brzegu (fallback)
                    const fallbackRow = fullDatabase.find(row => row.id === currentId);
                    const mainInfoRow = baseRow || fallbackRow;
                    
                    if (!mainInfoRow) return null;

                    // 2. Znajdujemy wiersz AKTYWNY dla zdań i słowa na froncie
                    let activeRow = mainInfoRow;
                    
                    if (tense !== 'Base' && tense !== 'mixed') {
                        const foundRow = fullDatabase.find(row => row.id === currentId && row.tense === tense);
                        if (foundRow) activeRow = foundRow;
                    }

                    let sentences = [];
                    // W nowym modelu z Excela, s1 zawiera treść komórki czasu
                    let conjugationContent = activeRow.s1 || activeRow.word;

                    if (tense === 'mixed') {
                        // Mix zdań ze wszystkich dostępnych wierszy dla tego ID
                        const allVariations = fullDatabase.filter(row => row.id === currentId && row.tense !== 'Base');
                        allVariations.forEach(row => {
                            // W nowym modelu mamy głównie s1
                            if (row.s1) {
                                const parsed = parseSentenceRow(row.s1);
                                if (parsed && parsed.en) sentences.push(parsed);
                            }
                        });
                        sentences = sentences.sort(() => Math.random() - 0.5).slice(0, 5);
                    } else {
                        // Zdania z aktywnego wiersza (Base lub konkretny czas)
                        // W Excelu mamy jedną kolumnę per czas, zmapowaliśmy ją do s1
                        if (activeRow.s1) {
                             const parsed = parseSentenceRow(activeRow.s1);
                             if (parsed && parsed.en) sentences.push(parsed);
                        }
                        // Jeśli w przyszłości dodasz s2-s5 do logiki mapowania, tutaj zadziała
                        for (let i = 2; i <= 5; i++) {
                            const raw = activeRow[`s${i}`];
                            if (raw) {
                                const parsed = parseSentenceRow(raw);
                                if (parsed && parsed.en) sentences.push(parsed);
                            }
                        }
                    }

                    return { 
                        word: activeRow.word,          
                        translation: mainInfoRow.translation, 
                        phonetic: mainInfoRow.phonetic, 
                        sentences: sentences,
                        conjugation: conjugationContent 
                    };
                };

                const displayData = getDisplayData();

                const handleStart = (clientX) => { setTouchEnd(null); setTouchStart(clientX); };
                const handleMove = (clientX) => { setTouchEnd(clientX); };
                const handleEnd = () => {
                    if (!touchStart || !touchEnd) return;
                    const distance = touchStart - touchEnd;
                    if (distance > minSwipeDistance) handleNext();
                    else if (distance < -minSwipeDistance) handlePrev();
                    setTouchStart(null); setTouchEnd(null);
                };

                const onTouchStart = (e) => handleStart(e.targetTouches[0].clientX);
                const onTouchMove = (e) => handleMove(e.targetTouches[0].clientX);
                const onTouchEnd = () => handleEnd();
                const onMouseDown = (e) => handleStart(e.clientX);
                const onMouseMove = (e) => { if(touchStart) handleMove(e.clientX); };
                const onMouseUp = () => {
                    if (touchStart && touchEnd && Math.abs(touchStart - touchEnd) > minSwipeDistance) {
                        handleEnd();
                    }
                    setTouchStart(null); setTouchEnd(null);
                };
                const onMouseLeave = () => { setTouchStart(null); setTouchEnd(null); };

                const resetCard = () => {
                    setNoTransition(true); setCardSide(1); setRotation(0); cancelSpeech();
                    setTimeout(() => setNoTransition(false), 50); 
                };

                const handleNext = () => {
                    setNoTransition(true); setCardSide(1); setRotation(0);
                    setTimeout(() => {
                        setNoTransition(false);
                        setCurrentIndex((prev) => (prev + 1) % currentWordIds.length);
                    }, 50);
                };

                const handlePrev = () => {
                    setNoTransition(true); setCardSide(1); setRotation(0);
                    setTimeout(() => {
                        setNoTransition(false);
                        setCurrentIndex((prev) => (prev - 1 + currentWordIds.length) % currentWordIds.length);
                    }, 50);
                };

                const handleCardClick = () => {
                    if (cardSide === 1) { setCardSide(2); setRotation(180); }
                    else if (cardSide === 2) { setCardSide(1); setRotation(0); }
                    else if (cardSide === 3) { showTranslation(); }
                };

                const showSentences = (e) => { if(e) e.stopPropagation(); setCardSide(3); setRotation(360); };
                const showTranslation = (e) => { if(e) e.stopPropagation(); setCardSide(2); setRotation(180); };

                const handleSpeak = () => {
                    if (!displayData || !window.speechSynthesis) return;
                    window.speechSynthesis.cancel();
                    // Jeśli widok zdań, czytaj zdania, w przeciwnym razie czytaj słowo (lub zdanie z koniugacji jeśli wybrano czas)
                    let textToSpeak = "";
                    if (cardSide === 3) {
                         textToSpeak = displayData.sentences.map(s => s.en).join('. ');
                    } else {
                         // Jeśli wybrano czas inny niż Base, czytamy treść z tego czasu (np. zdanie/koniugację)
                         // Jeśli to tylko słowo, czytamy słowo
                         if (tense !== 'Base' && tense !== 'mixed' && displayData.conjugation) {
                             // Usuwamy polskie tłumaczenie z nawiasów do czytania, jeśli tam jest
                             const parsed = parseSentenceRow(displayData.conjugation);
                             textToSpeak = parsed ? parsed.en : displayData.conjugation;
                         } else {
                             textToSpeak = displayData.word;
                         }
                    }

                    const utterance = new SpeechSynthesisUtterance(textToSpeak);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.85;
                    utterance.onstart = () => setIsSpeaking(true);
                    utterance.onend = () => setIsSpeaking(false);
                    window.speechSynthesis.speak(utterance);
                };

                const cancelSpeech = () => { if (window.speechSynthesis) window.speechSynthesis.cancel(); setIsSpeaking(false); };

                const highlightTargetWord = (sentence, targetWord) => {
                    if (!targetWord) return sentence;
                    // Prosta heurystyka: bierzemy pierwsze słowo z 'targetWord' jeśli to całe zdanie
                    // albo próbujemy dopasować całość.
                    // Dla bezpieczeństwa, jeśli 'targetWord' zawiera spacje (jest zdaniem), nie podświetlamy wszystkiego na czerwono,
                    // chyba że to jest dokładnie to.
                    // Tutaj uproszczenie: nie podświetlamy w trybie zdań, jeśli targetWord jest długie.
                    
                    const cleanTarget = targetWord.split('(')[0].trim(); // Usuń tłumaczenie jeśli jest w targetWord
                    // Jeśli targetWord to np. "I go", a w zdaniu mamy "I go to school", to można spróbować podświetlić "I go".
                    
                    const escapedTarget = cleanTarget.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(${escapedTarget})`, 'gi');
                    const parts = sentence.split(regex);
                    
                    // Jeśli nie znaleziono dopasowania całego zwrotu, spróbujmy chociaż główne słowo (jeśli dostępne w raw data)
                    // Ale w obecnym kodzie displayData.word to zawsze główne słowo (np. Go), więc użyjmy tego.
                    // Jednak displayData.conjugation może być "I go (Idę)".
                    
                    return parts.map((part, index) => 
                        part.toLowerCase() === cleanTarget.toLowerCase() 
                        ? <span key={index} className={`${isDarkMode ? 'text-red-400' : 'text-red-600'} font-extrabold text-xl sm:text-2xl`}>{part}</span> 
                        : part
                    );
                };

                const theme = isDarkMode ? {
                    bg: 'bg-gray-900', text: 'text-gray-100', headerText: 'text-indigo-400',
                    cardFrontBg: 'bg-gray-800', cardFrontText: 'text-white', cardBorder: 'border-gray-700',
                    cardBackBg: 'bg-indigo-900', controlsBg: 'bg-gray-800', controlsBorder: 'border-gray-700',
                    selectText: 'text-indigo-300', subText: 'text-gray-400', counterBg: 'bg-gray-800',
                    counterText: 'text-gray-300', buttonBg: 'bg-gray-800', buttonHover: 'hover:bg-gray-700',
                    buttonText: 'text-gray-200', accent: 'bg-indigo-800 text-indigo-200'
                } : {
                    bg: 'bg-gradient-to-br from-blue-50 to-indigo-100', text: 'text-gray-800', headerText: 'text-indigo-700',
                    cardFrontBg: 'bg-white', cardFrontText: 'text-gray-800', cardBorder: 'border-indigo-200',
                    cardBackBg: 'bg-indigo-600', controlsBg: 'bg-white', controlsBorder: 'border-indigo-200',
                    selectText: 'text-indigo-700', subText: 'text-gray-500', counterBg: 'bg-white/50',
                    counterText: 'text-indigo-800', buttonBg: 'bg-white', buttonHover: 'hover:bg-gray-50',
                    buttonText: 'text-gray-700', accent: 'bg-indigo-100 text-indigo-500'
                };

                if (loading) {
                    return <div className={`h-[100dvh] flex flex-col items-center justify-center p-4 ${theme.bg} ${theme.text}`}><div className="text-4xl mb-4 animate-spin text-indigo-500"><Icon path={iconPaths.layers} size={48} /></div><div className="text-lg font-semibold">Wczytywanie bazy Excel...</div></div>;
                }
                
                if (fileError) {
                    return <div className={`h-[100dvh] flex flex-col items-center justify-center p-8 ${theme.bg} ${theme.text} text-center`}>
                        <div className="text-4xl mb-4">⚠️</div>
                        <div className="text-xl font-bold mb-4 text-red-500">Problem z bazą danych</div>
                        <div id="local-file-warning" className="hidden mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg text-yellow-800 text-sm max-w-md text-left">
                            <strong>⚠️ Wykryto uruchomienie lokalne (file://)</strong><br/><br/>
                            Przeglądarki blokują wczytywanie pliku <code>bazaA1.xlsx</code>, gdy otwierasz stronę bezpośrednio z dysku.
                        </div>
                        <pre className="mb-6 text-sm bg-red-50 p-4 rounded text-left overflow-auto max-w-full whitespace-pre-wrap">{fileError}</pre>
                        <button onClick={() => location.reload()} className="bg-red-600 text-white px-6 py-2 rounded-lg">Odśwież stronę</button>
                    </div>;
                }

                if (!displayData) {
                    return <div className={`h-[100dvh] flex flex-col items-center justify-center p-4 ${theme.bg} ${theme.text} text-center`}><div className="text-xl font-bold mb-2">Brak słówek</div><p>Poziom: {level}, Kategoria: {category === 'all' ? 'Wszystkie' : category}</p></div>;
                }

                return (
                    <div className={`h-[100dvh] flex flex-col items-center pt-4 pb-[5dvh] px-4 font-sans transition-colors-all duration-300 ${theme.bg} ${theme.text} relative overflow-hidden noselect`}>
                        <div className="absolute top-3 left-3 sm:top-4 sm:left-4 z-50">
                            <button onClick={() => setIsDarkMode(!isDarkMode)} className={`p-2 rounded-full shadow-lg transition-all duration-300 ${isDarkMode ? 'bg-gray-800 text-yellow-400 hover:bg-gray-700' : 'bg-white text-indigo-600 hover:bg-gray-50'}`}>
                                <Icon path={isDarkMode ? iconPaths.sun : iconPaths.moon} size={20} className="sm:w-6 sm:h-6" />
                            </button>
                        </div>

                        <header className="w-full max-w-lg flex-none flex flex-col items-center space-y-3 mt-8 sm:mt-0 mb-2">
                            <h1 className={`text-2xl sm:text-3xl font-extrabold flex items-center gap-2 ${theme.headerText}`}>
                                <Icon path={iconPaths.layers} size={28} className="sm:w-8 sm:h-8" /> Fiszki Master v2
                            </h1>
                            
                            <div className="w-full grid grid-cols-2 gap-2 sm:gap-3">
                                <div className={`${theme.controlsBg} px-3 py-2 rounded-xl shadow-md flex flex-col justify-center transition-colors-all duration-300`}>
                                    <label className={`text-[10px] sm:text-xs font-bold uppercase block mb-0.5 sm:mb-1 ${theme.subText}`}>Poziom</label>
                                    <select value={level} onChange={(e) => setLevel(e.target.value)} className={`w-full bg-transparent font-bold text-sm sm:text-base outline-none ${theme.selectText}`}>
                                        <option value="A1">A1</option><option value="A2">A2</option><option value="B1">B1</option><option value="B2">B2</option>
                                    </select>
                                </div>
                                <div className={`${theme.controlsBg} px-3 py-2 rounded-xl shadow-md border-l-4 ${isDarkMode ? 'border-indigo-600' : 'border-indigo-400'} flex flex-col justify-center transition-colors-all duration-300`}>
                                    <label className={`text-[10px] sm:text-xs font-bold uppercase mb-0.5 sm:mb-1 flex items-center gap-1 ${theme.subText}`}><Icon path={iconPaths.tag} size={10} className="sm:w-3 sm:h-3"/> Temat</label>
                                    <select value={category} onChange={(e) => setCategory(e.target.value)} className={`w-full bg-transparent font-bold text-sm sm:text-base outline-none ${theme.selectText}`}>
                                        <option value="all">Wszystkie (Cały poziom)</option>
                                        {availableCategories.map(cat => <option key={cat} value={cat}>{cat}</option>)}
                                    </select>
                                </div>
                            </div>

                             <div className={`${theme.counterBg} px-3 py-1.5 sm:py-2 rounded-lg sm:rounded-xl text-xs sm:text-sm border border-white/10 font-semibold whitespace-nowrap ${theme.counterText} transition-colors-all duration-300 w-full sm:w-auto text-center mt-2`}>
                                {currentIndex + 1} / {currentWordIds.length}
                            </div>
                        </header>

                        <div className="relative w-full max-w-md flex-1 min-h-[250px] mb-4 z-10 perspective-1000">
                            <div 
                                className={`relative w-full h-full shadow-2xl rounded-2xl cursor-pointer transform-style-3d ${noTransition ? '' : 'transition-transform duration-700 ease-in-out'}`}
                                style={{ transform: `rotateY(${rotation}deg)` }}
                                onClick={handleCardClick}
                                onTouchStart={onTouchStart}
                                onTouchMove={onTouchMove}
                                onTouchEnd={onTouchEnd}
                                onMouseDown={onMouseDown}
                                onMouseMove={onMouseMove}
                                onMouseUp={onMouseUp}
                                onMouseLeave={onMouseLeave}
                            >
                                <div className={`absolute inset-0 w-full h-full rounded-2xl flex flex-col items-center justify-center p-4 sm:p-6 backface-hidden border-b-4 ${theme.cardFrontBg} ${isDarkMode ? 'border-gray-600' : 'border-indigo-200'} transition-colors-all duration-300`} style={{ transform: 'rotateY(0deg)' }}>
                                    {cardSide === 3 ? (
                                        <div className="w-full h-full flex flex-col animate-fadeIn">
                                            <div className="flex justify-between items-center mb-2 sm:mb-3 border-b pb-2 border-gray-200/20 flex-none relative">
                                                <h3 className={`font-bold flex items-center gap-2 text-sm sm:text-base ${isDarkMode ? 'text-indigo-300' : 'text-indigo-600'}`}>
                                                    <Icon path={iconPaths.book} size={16} className="sm:w-[18px] sm:h-[18px]"/> Zdania
                                                </h3>
                                                
                                                <div className="flex items-center gap-2" onClick={(e) => e.stopPropagation()}>
                                                    <div className={`px-2 py-1 rounded-lg border flex items-center gap-1 ${isDarkMode ? "bg-gray-700 border-gray-600" : "bg-gray-100 border-gray-300"}`}>
                                                        <Icon path={iconPaths.clock} size={12} className={isDarkMode ? "text-gray-400" : "text-indigo-500"}/>
                                                        <select 
                                                            value={tense} 
                                                            onChange={(e) => setTense(e.target.value)} 
                                                            className="bg-transparent text-xs font-bold outline-none w-[100px] sm:w-[120px]"
                                                        >
                                                            <option value="Base">Podstawa</option>
                                                            {availableTenses.map(t => (
                                                                <option key={t} value={t}>{t}</option>
                                                            ))}
                                                            <option value="mixed">Mix czasów</option>
                                                        </select>
                                                    </div>
                                                    <button onClick={showTranslation} className="p-1 rounded-full hover:bg-gray-200/20" aria-label="Zamknij">
                                                        <Icon path={iconPaths.close} size={18} className={isDarkMode ? "text-gray-400" : "text-gray-500"} />
                                                    </button>
                                                </div>
                                            </div>
                                            <ul className="space-y-3 sm:space-y-4 text-base sm:text-lg text-left overflow-y-auto pr-1 custom-scrollbar flex-1" onClick={(e) => e.stopPropagation()}>
                                                {displayData.sentences.length > 0 ? displayData.sentences.map((s, i) => (
                                                    <li key={i} className="flex flex-col gap-1">
                                                        <div className="flex gap-2 leading-snug">
                                                            <span className={`font-bold select-none mt-0.5 ${isDarkMode ? 'text-indigo-400' : 'text-indigo-300'}`}>{i+1}.</span>
                                                            <span className={isDarkMode ? 'text-gray-200' : 'text-gray-700'}>{highlightTargetWord(s.en, displayData.word)}</span>
                                                        </div>
                                                        <div className={`pl-6 text-sm sm:text-base italic ${theme.subText}`}>({s.pl})</div>
                                                    </li>
                                                )) : <li className="text-center opacity-50 italic mt-4">Brak przykładowych zdań dla tego czasu</li>}
                                            </ul>
                                            <div className={`mt-2 text-[10px] text-center italic opacity-60 ${theme.subText}`}>Kliknij tło, aby wrócić</div>
                                        </div>
                                    ) : (
                                        <>
                                            <div className={`absolute top-4 left-4 sm:top-6 sm:left-6 text-[10px] sm:text-xs font-bold uppercase flex flex-wrap items-center gap-1 sm:gap-2 max-w-full overflow-hidden ${theme.subText}`}>
                                                <span className="truncate max-w-[80px] sm:max-w-none">{tense === 'mixed' ? 'Mix' : (tense === 'Base' ? 'Podstawa' : tense)}</span>
                                            </div>
                                            <div className="flex-1 flex items-center justify-center w-full px-2">
                                                <h2 className={`text-3xl sm:text-5xl font-black text-center break-words leading-tight ${theme.cardFrontText}`}>
                                                    {displayData.word}
                                                </h2>
                                            </div>
                                            <div className={`absolute bottom-4 sm:bottom-6 text-[10px] sm:text-xs flex items-center gap-1 sm:gap-2 font-medium ${theme.subText}`}>
                                                <Icon path={iconPaths.rotate} size={12} className="sm:w-[14px] sm:h-[14px]"/> Kliknij, aby obrócić
                                            </div>
                                        </>
                                    )}
                                </div>

                                <div className={`absolute inset-0 w-full h-full text-white rounded-2xl flex flex-col items-center justify-center p-4 sm:p-6 backface-hidden border-b-4 ${theme.cardBackBg} ${isDarkMode ? 'border-indigo-950' : 'border-indigo-800'} transition-colors-all duration-300`} style={{ transform: 'rotateY(180deg)' }}>
                                    <div className="absolute top-4 right-4 sm:top-6 sm:right-6 text-[10px] sm:text-xs font-bold text-indigo-200 uppercase">Tłumaczenie</div>
                                    <h2 className="text-2xl sm:text-4xl font-bold mb-2 sm:mb-3 text-center">{displayData.translation}</h2>
                                    <div className="bg-white/20 px-4 sm:px-6 py-1.5 sm:py-2 rounded-full font-mono text-base sm:text-xl mb-6 sm:mb-8">{displayData.phonetic}</div>
                                    <button onClick={showSentences} className={`font-bold py-2 sm:py-3 px-4 sm:px-6 rounded-xl shadow-lg active:scale-95 flex items-center gap-2 text-sm sm:text-base transition-colors ${isDarkMode ? 'bg-gray-800 text-white hover:bg-gray-700' : 'bg-white text-indigo-700 hover:bg-indigo-50'}`}>
                                        <Icon path={iconPaths.book} size={18} className="sm:w-5 sm:h-5"/> 
                                        {tense === 'Base' ? 'Zdania (Mix)' : `Zdania (${tense})`}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="w-full max-w-md flex-none space-y-3 z-20 mb-2">
                            <div className="grid grid-cols-2 gap-3">
                                <button onClick={handlePrev} className={`${theme.buttonBg} ${theme.buttonHover} ${theme.buttonText} font-bold py-3 rounded-xl shadow-sm border ${theme.controlsBorder} flex justify-center gap-2 active:scale-95 transition-colors-all duration-300 text-sm`}>
                                    <Icon path={iconPaths.left} className="w-5 h-5" /> Poprzednia
                                </button>
                                <button onClick={handleNext} className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-xl shadow-lg flex justify-center gap-2 active:scale-95 transition-colors duration-300 text-sm">
                                    Następna <Icon path={iconPaths.right} className="w-5 h-5" />
                                </button>
                            </div>
                            <button onClick={handleSpeak} disabled={isSpeaking} className={`w-full text-lg font-bold py-3 rounded-xl shadow-xl active:scale-95 flex justify-center gap-3 border-b-4 transition-colors duration-300 ${isSpeaking ? "bg-emerald-400 border-emerald-600" : "bg-emerald-500 hover:bg-emerald-600 border-emerald-700 text-white"}`}>
                                {isSpeaking ? <Icon path={iconPaths.volX} size={24} className="sm:w-6 sm:h-6"/> : <Icon path={iconPaths.vol} size={24} className="sm:w-6 sm:h-6"/>}
                                {isSpeaking ? "Odtwarzanie..." : (cardSide === 3 ? "Czytaj zdania" : "Czytaj wymowę")}
                            </button>
                        </div>
                    </div>
                );
            }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<FlashcardsApp />);
        } catch (err) {
            document.getElementById('error-overlay').style.display = 'flex';
            document.getElementById('error-message').textContent = err.toString();
        }
    </script>
</body>
</html>
